 	
# Thoughts on the Loop: Defining the Orbit System

> Originally published at https://ict.senecacollege.ca/~david.humphrey/writing/Loop.html
> (2001) This is an as yet unfinished paper exploring the Loop's philosophical, aesthetic, and technological implications. After discussing what the Loop is, I set-out to define a new "machine" for expressing loops called Orbit. If you'd like to help build this, send me an e-mail 

## Introduction

During the fall and winter of 2001, I spent a good part of my day-dreaming time imagining a new medium. After a number of unsuccessful attempts to describe it to colleagues, I decided to sketch out a more complete description. This paper is an attempt to define the philosophical, aesthetic, and technological characteristics of this new medium, hereafter referred to as Orbit.

## A Musical Interlude

While attending a symphony with some friends in the fall of 2001, I began to consider critically for the first time a control structure in computers and computer programming called the Loop. During the intermission one of my companions made a comment about the poor seats my wife and I had been sitting in--we were seated in the fourth row near the centre, while she was in a balcony near the back: "You don't get the real experience when you are so close," she said. "One needs adequate distance to allow the separate voices of the instruments to become one." I hadn't felt as though our seats were inadequate to the task of listening to the music at the time, so sitting down for the second half of the performance I decided to see what my particular vantage afforded me that hers did not. The music began and I was struck by something that I had sensed before, but to which I had paid no special attention. It wasn't the music as whole that interested me, rather it was the music as composite construction. Here were fifty musicians not playing as one, which is what the word symphony means after all, but playing with one another and at the same time. The percussionists, I noticed, spent most of the second-half awaiting a particular series of bars near the end of the piece. The double-bassist too was free enough to start a conversation with another string player to his left. As the performance ended I realized that what I had witnessed from my fourth-row seat was the starting and stopping of musicians, and the importance of the absence rather than the presence of people playing.

Perhaps all this strikes you as a philistine's admission of musical ineptitude. And there is something to this assessment. However, what is important here is the idea that sometimes the whole is both more and equal to the sum of its parts. From the balcony my cultured friend was able to experience the music without the individual musicians to distract her. I, on the other hand, heard not so much the performance as the performers. Neither is right or wrong, although I think my friend could argue convincingly that her experience of the piece was "better" musically. As I have no musical credentials to argue the opposite view, I will hastily leave my thoughts on the symphony behind and try to sketch for you the flow of ideas that took me from the idling of musicians to the beauty of loops and repetition in computers.

## Programs that Do Nothing?

During the months leading up to my night at the symphony, I had been reading the work of John Maeda, director of the Aesthetics + Computation Group at M.I.T. Maeda's attempts to reconcile the worlds of art, design, and computation were in keeping with the ideas I had been working through on my own. Recently my own work, as well as my teaching, had been focused on developing computer programs for business purposes. These included database applications, web sites, network programs, and the like. What I found in Maeda's work was the expression of an idea that had until then remained half-formed in the back of my mind, namely, that computers are more than merely business tools. In the computer's uses as a numerical calculator, sorter, searcher, and data retrieval machine, it is well understood and documented. However, as an artistic or a purely aesthetic medium, less is understood, and even less written. I decided to take what I knew about developing applications using computer programming languages and create a series of experimental programs, what I would later call "Programs that Do Nothing."

My first attempt was to build a program to discover graphical patterns using a simple two-dimensional algorithm that read everyday computer files. The user of the program was asked to pick a file on their computer, which could be any file of any type. The program would then proceed to read the file in a binary form and convert its contents (i.e., the bytes) into a series of Cartesian co-ordinates and RGB colour values. After experimenting successfully with this program on my own, I decided to release it as a lab to students in a GUI Programming course I was teaching. The students were asked to first play with the program as it was, and then to alter it and create their own modified pattern-drawing algorithm. Then, in a departure from what I had required in previous labs, I asked the students to submit the results of their program (i.e., the pictures), rather than the code that produced them.

The results of this experiment were interesting, but not for the reasons I had anticipated. I found that the majority of the students did not understand what I was asking them to do. After some discussion it became clear that the problem was not that they misunderstood the assignment or lacked the technological abilities to carry out the task. No, the issue was that many of the students couldn't understand the purpose of the assignment: "Shouldn't we hand in our code?", "Why are we doing this?", "What's the point of the picture?", "Haven't you already done everything?", etc. Introducing a program that does Nothing to students trained to write programs that do Something was what stood in the way. This was a problem of domain, for the students had been trained to think about computers and computer programs in a purely pragmatic way--as a business tool or perhaps as a "number cruncher." The idea of experimenting with computers in an aesthetic or artistic way was foreign to them.

## More ideas on the Loop

The main component of this file-visualization program was a loop that read bytes from a file, converted them to co-ordinates and colours, and then drew them on the screen. My experiments with this program got me thinking more intently about loops and what one might do with a loop. I realized that the beauty of the loop as programmatic structure lay in the fact that it is at once a static and kinetic expression in language. By this I mean that the loop is nothing more than a set of discrete steps which are the same no matter if they are executed once or an infinite number of times (actually, the steps retain their meaning even if never executed). When we read a computer program, we see the body of a loop both with a sense of its static presence on the page/screen, but also, and perhaps more importantly, with the knowledge of what it could and will be. We can therefore talk about a program "being" run, because the loop propels the code out of its stasis on the page/screen and into Time. Even if a program does not include a loop, it still participates in this process, since all programs are run within the operating system's main loop. Therefore, it can be said that the loop is what we as users of a computer actually know as a program.

The problem with our current view of computers, and computer programs generally, is that we tend to look at them from one of two perspectives. Either we are programmers like my students (or like me listening to the symphony in row four) who can't see past the process of developing code; or we are users who are discouraged from, or unable to peer inside the running program (my friend in the balcony experiencing only the whole). It turns out that there is a third perspective (and perhaps more still): we can also view the program as process. You might think that programmers already do this, but I would argue that they do not. When a programmer writes her code, she is breaking down the experience of the user, the experience of the program running, into discrete pieces, be they functions, classes, or whatever programmatic unit is currently in vogue. She takes the program running in Time and freezes it, stops it, and reduces it to its most basic elemental expression. The program as code becomes the simplest expression possible of motion without motion, or something in Time expressed as something in space (i.e., the space on the page or screen). As a result reading (and writing) the code is not the same as running the program.

Let's consider an example. The first program I ever wrote was written in a programming language called BASIC. Here's the code:

```
10 PRINT "Hello World!"
20 GOTO 10
```

When run, this program will produce the following:

```
Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World! Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!
```

and so on

I've included this many "Hello World!"s to demonstrate something that will be well known to most readers, but perhaps not understood by others: this program is an example of an infinite loop. Much as the Mobius Strip has no end, the Infinite Loop is ended only by a loss of power, or by user intervention. This simple loop contains only two lines of code and yet it is sufficient to describe all possible loops that could be written. By examining it we can say that a loop has some portion of itself devoted to its own repetition (e.g., the statement Goto 10) and termination (if any), as well as a series of steps to be repeated--what might be called the Body of a loop.

Some people will look at this loop and call it the simplest loop that one can write. I suppose that this is true, in as much as the body of the loop is simple and there are no calculations being done to check for a termination case. Yet, I can imagine a simpler loop, and one that will help to demonstrate what it is about the loop that fascinates me so. Here is the code:
10 GOTO 10

This is perhaps the shortest loop that I can imagine, although someone may be able to find an even shorter expression of the same. In one line of code we have the expression of something at once trivial in its simplicity, yet impossible to fully grasp. What makes it simple is not its length, for I could write an even shorter program:
10 END

In case it isn't clear what each program will do when run, let's examine them briefly. I'll start with the second because it is a bit easier to see. When the program begins it will perform the instruction at line 10 (the first and only line), which will halt the program and cause it to finish. You could say that this program does nothing, which isn't actually true. This program starts and stops.

The former program starts out in a similar way. When the program begins execution it performs the instruction at line 10, which will cause the execution to go to line 10, which will cause execution to go to line 10, and so on. The two programs have many of the same characteristics: both are one line in length, both are roughly equivalent in terms of the number of characters that it took to express them (10 in the former, 6 in the latter). As a result it is only fractionally faster for the programmer to read END than it is GOTO 10. The similarities are such that at a quick glance a programmer could conclude that these two programs are essentially the same. This is true for the user as well, whose experience of both programs is that they do nothing--one of which happens to do nothing forever. However it is less than satisfying to end our discussion by saying that these two loops do nothing, as though "nothing" could be made to mean both a finite and an infinite process at one and the same time. What is needed instead is a fuller understanding of how each program achieves its Nothing; for herein lies the distinction I wish to make.

## How to Do Nothing

If we look again at `GOTO 10` we see that from a purely computational point of view, `GOTO 10` "does" as much as any other loop. It is only on account of the expectations we bring as computer users about what a program should do that we see `GOTO 10` as something outside the norm. With only a few changes `GOTO 10` could be turned into a clock application. With more changes it could be turned into an editor or word-processor. With still more changes it could become an operating system. The point is that all of these other useful programs do Something in the same time it takes `GOTO 10` to do Nothing. As a result one might say that `GOTO 10` is an attempt to redefine programming as a pure expression of Time in language.

Because GOTO 10"does" Nothing and is therefore a very simple program, it is useful in order to demonstrate the three perspectives a person can take when examining a program--what I called above the programmer, the user, and the person who views the program as process. To demonstrate the first perspective you have to read `GOTO 10` much as you would END. Both are merely instructions to be executed. If it is possible, and I would argue that it is not, the programmer reads this line of code like any other and the time it takes to complete it is not infinite, but finite in as much as it takes time to actually pass his eyes over the characters on the screen. On the other extreme is the user of `GOTO 10` who runs the program and then waits for Something to happen, or we might say waits while Nothing happens. To the user there is no evidence that Something is happening, even though Something is happening, and happening very quickly. What the user calls Nothing is really the cumulative effect of the tenth line of the program being run and re-run. However, what was called Nothing in the case of END is actually the period that ensues the termination of the program, which, as it happens, is a lot like what happens in the case of `GOTO 10`.

I don't want to suggest to you that anything is missing from these two descriptions or views (i.e., the programmer's and the user's). Both are correct, and both are incomplete without the other. What is necessary to fully understand `GOTO 10` is the experience in Time of a repeated action. To really see what is going on one has to be the programmer and the user at the same time, to see that the infinite nothingness of the user is actually a repetitive realization of the programmer's finite expression. It isn't as hard as it sounds. Let's look at the code once again:

```
10 GOTO 10
```

When I read this program I am struck with a feeling of awe at my inability to exist outside of Time, of my finite being. I read `GOTO 10` and my immediate desire is to then read what is written at line 10. My eye jumps back to the beginning of the line and I'm shocked to realize that I've already been reading line 10, but read it again. At this point (or after a few more iterations of this process) I am forced to stop reading and begin to imagine something larger, faster, and more real than this one line of code. As a user I would be protected from this, and lulled into a feeling that nothing is happening, because I would not be able to see the action of what is really going on. Similarly as a programmer/reader I assume that once I have read the loop through a few times I have understood the process and can therefore stop. In neither case have I really experienced the weight of what is actually going on here. For contained in this 10 character program is the possibility of an infinite, or more correctly, of an un-ending reality. To say that I as programmer or user have understood this is to refuse to participate in the reality of Time, much as the mathematician draws a circle around nothing and calls it zero in order to contain what would otherwise swallow him whole.

At this point I could introduce other examples of more complex loops. We could examine nested-loops to N depths, or look at how the introduction of certain variables changes the lifetime of the loop. All of this would get us no closer to where we need to be than does GOTO 10. For everything I could hope to show you about loops is present in it. No matter which loop we examine there is currently no way for its static and kinetic nature to be experienced at once, no way to be both the programmer and the user, no way to sit in the fourth row and the balcony. However, this isn't the same as saying that there shouldn't be, which is what I'd like to argue now.

## What a Loop Machine Might Look Like

At this point I want to move away from the discussion of our current limitations in experiencing the program as process and instead explore what a solution might look like. As has been said above, the main problem to be overcome is that we need a way to see both the static nature of the loop as code at the same time that we are experiencing its affect in Time. The loop, as I've shown, is at once moving and still. Therefore, any attempt to capture this dual nature will require a medium that both stands still and moves at the same time, or perhaps moves by standing still. The impossibilities of this proposal become overwhelming when one attempts to implement such a theoretical proposition. After a working through a number of failures in trying to imagine how this might be done using a computer, I realized that it would only become possible with the introduction of multiple computers.

The design I eventually settled on was a network of individual computers arranged in a circle with each monitor pointing to the centre of the circle. Each monitor becomes a single point in an infinite spatial loop (i.e., a perfect circle). The user of the system does not interact with the computers using any input devices. Rather she stands in the centre of the loop and watches the screens around her. An image is displayed on one of the monitors, and then moves to the monitor directly beside the first. The process is continued around the loop. When the image makes a complete rotation it either terminates or continues, depending on the nature of the loop. Due to the arrangement of the computer screens, and to the fact that the image moves around them much as a satellite around the earth, I decided on the name Orbit for the system.

## Defining Orbit

Orbit is an attempt to bring into view the two opposing natures of the loop at once. Multiple monitors represent the units of the loop, its discrete elements in language. Much as `GOTO 10` is a single expression, so too each monitor becomes a single or discrete entity within the larger context of the loop's body. The movement of the image across the monitors in real time manifests the process of the program being run. However, unlike film, which is a medium with similarities, Orbit forces the user to recognize the duality of the static and dynamic by having the display extend 360 degrees outside her field of view. She can watch a part of the loop, but to experience the loop in its entirety means that she must follow the image around the room by moving her body. In this way the medium encourages the user to become engaged in the process of the loop, to participate in the animation of the static. Each individual foot shuffle or bodily rotation is another manifestation of what is actually taking place with all loops.

As I became more comfortable with Orbit's design, I began to shift my focus to imagine what could be expressed using this new medium, or more correctly, how it could be expressed. I began by considering what the restrictions might be on the single image if it was to approximate the unit of code contained within a loop. I realized that the unit of code does not change in its expression, but in its execution. Programmers will be familiar with this concept as that which allows for repetition with variation, in other words using a variable x to stand-in for a series of possible values. The unit of code is expressed in terms of x, but the execution is in terms of the value set. This potential for change is only possible at the execution level, not the expression level. So for Orbit I believe that an image must not change while being displayed on a single screen. However, as it moves between screens, the image may be altered in some way, much as x may become x + 1. To the user the image will have changed, but the change will be apparent, where modern computers are expected to make such changes faster than can be registered by the human eye. As the image moves from screen to screen, subtle (or not so subtle) changes are made which demonstrate the development through an incremental process.

I then wondered if one image could move concentrically across the monitors, could two images move in opposite directions? What about multiple images in the same direction moving at different speeds? I realized that much of what is accomplished using loops is done by nesting loops in side one another (cf. the canonical Bubble Sort). If Orbit is to be a realistic Loop Machine, then it must be capable of executing nested loops. Actually, nothing would preclude an Orbit system from being developed in which multiple Orbit applications were used and intersected, both physically and computationally. Imagine, for example a loop that both flipped an image around the x-axis as well as stripped the colours producing a gray-scale image. What in programmatic terms would be accomplished with multiple loops, in Orbit could be done by interlacing distinct Orbit loops within one another. However, this is beyond the scope of this discussion.

...TO BE COMPLETED...
