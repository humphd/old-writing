
# Agreeing to Open Up: Ideas for Open Source at Seneca

> Originally published at https://ict.senecacollege.ca/~david.humphrey/writing/OpenSourceSeneca.html
> I wrote this paper during the exam period 2002 as a way to express my ideas about how OS could be better integrated at Seneca. I circulated the paper to a number of my colleagues who shared similar ideas. Since writing this, a number of things have happened at Seneca (none of which are directly the result of this paper, but are all in line with what I hoped we could achieve): 1) we have begun an annual Open Source Symposium to discuss and share OS ideas with other college and university faculty; 2) the Centre for the Development of Open Technology (CDOT) has been born. While still in its infancy, the centre has the potential to link the individual OS work going on at Seneca. 

## Introduction

One of the main reasons I was drawn to Seneca as a teacher of computer programming was a dual desire to teach and be taught. Since arriving I have set for myself the goal of always being the most active student in my class--something that I (luckily) have not always been able to achieve. In my role as learner within the college, I have been interested in exploring ways to take what goes on in the classroom and expand it into extra-curricular projects. For the past year I have focused my energy on promoting and expanding the Code Poets group (http://codepoets.dufunk.com), and within Code Poets the Copenhagen Project (http://hermes.senecac.on.ca/copenhagen.codepoets). The former is a developer community portal, and the latter an umbrella project for all open source work being done in Microsoft's .NET Framework at the college. Of the posts to Code Poets, I am the only active writer despite nearly 100 registered users. Copenhagen currently includes four projects of note: one of these was written by a student, the rest by myself. These numbers speak for themselves.

One year later I stand at the beginning of another Fall semester, filled with new students and new possibilities, and I take stock. In writing this paper I hope to explore some of the reasons why Code Poets and Copenhagen haven't worked as well as I had hoped. My focus however will not be on the failure of these groups so much as a discussion of what I think needs to be done in order to foster different attitudes in students and faculty, as well as to create an environment where such work is possible. To this end I begin with a discussion of why I think it important for faculty and students to work collaboratively on development projects that sit between the classroom and the club-room. Following this I explore the potential of applying open source methodology and philosophy to the work we do at Seneca. Three initiatives are presented to demonstrate how Seneca could better engage and support its academic and development communities, all of which incorporate the concepts of open source development, and collaborative, evolutionary programming. I conclude with practical suggestions for moving forward.

## Defining the Problem

I think it necessary to first establish why having students and faculty work collaboratively on open source projects is important. I realize that not all of my colleagues will agree with this idea, and I'm sure that there are students who also don't share my vision. However, I feel that without this type of atmosphere the work we do as teachers and students of programming will never leave the classroom. And, if this knowledge is to become relevant to our students, to translate into life-long skills, it must become something that more closely resembles programming in the real-world. The significance of real-world computing is no less important for our faculty, who are required to keep pace with the technology and ideas growing outside the classroom. I would argue that no matter how one chooses to define "real-world," the fact remains that it differs greatly from what is practiced in the classroom.

The classroom is constructed. It does not exist. For example, I as a teacher of programming am free, or perhaps obliged, to give assignments that are more pedagogical than practical in an effort to demonstrate to the students concepts important to the course. The students in turn are freed from the obligations that would be imposed upon them if their programs had to be delivered to a customer: whether the programs work or not, they can and must be submitted. The emphasis is clearly not on the program, but supposedly on the learning--one could argue though, that the emphasis is really on the evaluation. It turns out that this freedom from the "working program" actually derails the development cycle, creating a stumbling block for students who are working to become future programmers. Rather than learning to write software that works, we teach our students to produce throw-away software that can be created within a fixed period; in other words, software that does not work.

The classroom is also problematic in the way it perpetuates and encourages closed models of development and learning. Students are, for the most part, restricted from helping or being helped by their peers for fear of being labeled cheaters. For similar reasons of logistics and evaluation, we as teachers enforce this, isolating our students and telling them that they may not copy or consult one another's work, nor that of someone outside the class. Furthermore, they are not allowed to consult books, the web, or other resources when they need them most (i.e., during examinations). The teacher/student hierarchy is limiting in the way it forces teachers to withhold information at key points in the course, and all in the name of fair evaluation. Neither the student nor the teacher is really free to learn or teach in an open and transparent way. Instead, the flow of knowledge is closed; and unfortunately, closed in both directions. Clearly the restrictions just mentioned are beneficial for the operations of the academy. However, from the perspective of the life-long programmer, they make less sense.

What is the answer to these seemingly unsolvable problems? In my view there is no easy solution to be found within the classroom. The machinery of the classroom is not readily changed, for its rubrics, methodologies, and philosophy are now as important to the student as they are the teacher. Thus we must look toward supplementing what goes on in the classroom with activities and opportunities that are not subject to the challenges outlined above. To criticize the classroom in order to achieve this is neither helpful nor productive. What happens on the edge and outside the classroom is more fertile ground.

## Recognizing Failure

The idea of approaching the problem outside the classroom is one that I've been exploring for the past year. As I mentioned in my introduction I have been working to build the Code Poets group and Project Copenhagen for this purpose. Both projects were conceived with the goal of getting students and faculty to write code together that gets released to the public as a way of: a) teaching ourselves; b) teaching others; c) giving back to the web community that has given us so much. After a year of working on these projects I am left with numerous web sites, on-line essays, and tens of thousands of line of code--all my own. I have been successful at getting people to come out to meetings, and can get them to sign club-lists, but have been unable to translate this into real creative participation. After a period of unproductive disappointment, I am now interested in answering the question of why this is so.

Upon reflection I now realize that there are numerous reasons for this outcome. First, I am aware that many, if not all students are busy with their school work--obviously, since I am among those adding to their assignments and readings. Second, I can imagine that some students don't have time due to family or other personal commitments (i.e., jobs, domestic issues, etc.). Unlike the first group I mentioned, I don't believe that there is much that can be done to free these students from their responsibilities. This still leaves a third group of students, who I will call the Drivers, who have both the talent and the creativity to get things done. And yet, where are they? I have been unable to find them, or at least they haven't found me. So I can conclude one of two things: 1) that they don't exist, which I reject, for I've seen them in my classes; or 2) that the right things haven't been done yet to attract, retain, and excite them.

What I would like to do is find ways to open this type of activity to the first group of students I listed above, namely, those who are busy with study, and at the same time entice those who are waiting for the right project to come along in order to get involved. I believe that something more organized and mainstream than Code Poets or Copenhagen needs to be created at Seneca. As I look around for similar work being done by my colleagues, I am immediately drawn to the birth of open source at Seneca, specifically at the hands of John Selmys. I believe that herein lies the answer to the problem of creating a self-sustaining collaborative development community within Seneca, and I can imagine three ways of making it happen.

## Open Source as Course

My first suggestion is to create a professional option course on open source programming and philosophy. At first this may seem to invalidate my earlier point that we cannot work from within the classroom. However, I feel that in order to legitimize this type of work in the minds of students and faculty, open source must be put on par with other development models and philosophies promoted at Seneca. The course would do two things. First, the students would embark as groups on open source projects of their own choosing or design. They would work on these throughout the term--it would look something like the Systems course we now have, with one important difference: students would be encouraged to pick-up projects from previous terms and continue working with them. Second, the course would introduce the students to open source philosophy generally. I believe that this is the most important objective. I have found through communicating with students that many don't see the benefit or merits of doing this type of work. They are ensnarled in copyright, intellectual property, and economic issues, which are, in my opinion, perpetuated by the academic environment in which we work (i.e., don't copy from others, don't cheat by using external resources, etc.). The structure of the course would be half programming and group process, with much of this half being done on their own time, and the other half devoted to reading and discussing open source literature.

In my opinion there is nothing at Seneca that encourages collaboration. Period. It doesn't exist with my first semester students, nor with my final semester students. To them working in groups means working with N-1 other people who simply put their individual efforts into one binder or on one disk at the end of term. And I don't believe that this will ever improve on its own. Collaboration has to be taught and fostered. It has to be demonstrated. Imagine a course where marks are assigned for process (i.e., group process) rather than product. Formal accountability structures and properly managed peer-evaluation mechanisms would follow the projects throughout the term. Perhaps at the end of the term a wonderful piece of software would be produced, perhaps not. In either case the goal would be that the students learned how to work as a team to produce something larger than what they could do on their own. This is a movement away from the idea of software that can be built in a term, and toward real-life software that grows and changes over time. To achieve this one of the most important elements of the course would be the focus on keeping work from previous terms alive. This would help to address one of the issues I discussed earlier, namely, that of the working program vs. the semester defined program. If a project failed or was left incomplete in one term, it would be carried forward and evolve at the hands of a group in the next.

In order for this course to succeed it would have to demonstrate practically the ideas it presents. Having already discussed some of the issues with the classroom as it exists today, every attempt would have to be made to re-imagine how the course is taught without invalidating the essential elements of: evaluation; responsibility; a core outline; timelines; etc. At the same time, the emphasis would need to be shifted from the individual to the group, or from the individual as autonomous worker to group-member. Issues of accountably and respect would be the most important: How are "slackers" dealt with? What happens when deadlines are missed? How is proper communication and peer support taught and demonstrated? What mechanisms are in place to allow true peer accountability without sacrificing the role of the instructor? What is the role of the instructor? What is a finished product in the culture of multi-term projects? These are by no means easy questions to answer. And yet they must be answered.

## Open Source as Research

Second, I propose that what I have started to do with my own open source work this summer, with Code Poets and Copenhagen, as well as the work of other professors and students, be collapsed into a college-wide (or Seneca@York CS-wide) infrastructure for open source collaborative development. On my own this summer I was able to obtain access to a server (cnsint12) from ACS to run CVS, which I'm now using to manage my project libraries. I was granted web space on numerous servers to present content to the Seneca community and world at large. I also received all the development tools I needed, whether free or not, through the college. In short, I have proven that the technology exists to support such an initiative. What doesn't exist currently is the project management and commitment to get projects started, or more importantly, keep them going. How does a student or faculty member with an idea get started? Who do they turn to? Who will guide them through the process of getting the necessary accounts? Of finding the necessary people to help? Of obtaining project management supervision, peer-vision, and willing partners? I think that we should build an infrastructure to support our students and faculty as they work together on projects that span courses, and exist outside the confines of the semester. Imagine providing this type of real-world training to students (and faculty) on how to design, start, maintain, and publish medium- to large-scale software projects.

Some of my colleagues might argue that this is already being done in the later Systems courses. I would disagree. First, the software built for the Systems course is detached from the students: they are not the users of their own software, and therefore don't care about it after the course has ended. Also, the majority are engaged in repeatedly building one-off e-commerce "sites," whether fat or thin. In making these observations I don't wish to criticize Systems or the work being done there. While it teaches a particular type of programming, and attempts to introduce group work, I believe that it is limited by the fact that it is confined to the classroom and aimed at business applications. In addition to this I believe that we need to start writing software that lives longer than one term and which is actually used by Seneca faculty and students. Software that must be maintained, debugged, updated, ported, etc. Where is this experience now? In other words, where is the experience of the real-world developer now?

If I mention institutions like Berkley, MIT, Stanford, or Carnegie Mellon, numerous valuable computing initiatives and projects come to mind. The university has long been the birth place of important computer advancements. I believe that the college also has much to offer. Even if we don't initially, or ever produce complete operating systems, databases, or networking libraries, there is nothing stopping us from solving problems specific to ourselves and our own needs. All of the projects that have come out of university computer science labs have addressed problems that needed to be solved by the people who ended-up solving them. We too can and should be solving our own problems. It is less a question of how we do this or if we can do this, and more a question of determining what our needs or problems are. In short, we should be working together to find and solve problems appropriate to our faculty and students, and thereby identify, define, and create our own community.

Some others may also suggest that what I am describing already exists in Source Forge (http://sourceforge.net)--one of, if not the largest repository for open source projects on the web. My idea isn't to duplicate or replace Source Forge, but rather to capitalize on Seneca's strengths: community and a shared environment. Where Source Forge links people in cyber-space, we could link people in physical- and cyber-space. Here at Seneca people meet one another daily, have access to hundreds of computers and dozens of servers, labs, and other resources. I am also aware as I meet with my colleagues the incredible depth of experience they bring to the college, not to mention that of our students. What if we could organize this properly and really provide the guidance and leadership our students need to blossom as developers? What if this could also be done for our faculty too?

Another point that needs to be raised with regard to this second idea, is that we should do more to keep in contact with our graduating students. One of the problems with my idea above is that it requires some talent/knowledge in programming. In my experience at Seneca, the graduating students take with them the knowledge and skills necessary to do much of the work I'm describing. These skills don't exist in the majority of the first semester students; but the desire to be a part of something like this does. So there needs to be a way to keep this talent/knowledge associated and connected with Seneca. For example, most of the people who have been interested in working with me on Project Copenhagen have been students who are recently graduated. They have now become self-directed learners and are willing to pick-up a new language, in this case C#. However, when I tried to get CVS, web, and database accounts for them at Seneca, I was denied: "Only current students can have accounts." On the one hand, this makes sense: Seneca can't provide an account to anyone who wants it. And yet other larger institutions have for years been granting accounts for life (e.g., U of T with its e-mail accounts). What if a new type of account could be created for people working on Seneca's Open Source projects, separate from the main accounts, and with access to only those resources necessary to do the work of the group? Again, there isn't a technological limitation here.

In addition to our graduating students, we should also consider the pool of talent available to us through York University and from our feeder high schools. York is perhaps the best partner we could wish for, as its students are taught the theory our students lack, but have none of the technical training (i.e., breadth of programming languages, databases, networking, etc.) our students receive. In attempting to mix these two different cultures, some political as well as social work would need to be done: neither group really understands the other. However, as someone who has worked in both worlds I can attest to the fact that a merger is indeed possible. As we look forward to the completion of the TEL building, one of the most significant barriers will be overcome, namely, physical proximity. As the students literally become one body in the halls, why could they not also unite on common programming projects?

The extension of this same invitation to high-school students would also be a positive step for the college on a number of levels. First, our projects would gain a broader base of developers, designers, etc. In each of the terms I have taught WIN133, there have been one or two students who have arrived as proficient programmers. These students would benefit from being able to engage in more challenging work than what they are being given in high school. The second advantage to the college is the free advertising that would be done by students who told their friends about the type of interesting and relevant work that was going on at Seneca. When the time came for them to apply to a post-secondary institution, Seneca's name would be well-known and respected.

## Open Source as Company

The third idea grows out of the second, and would be something for much later on. As Seneca's open source development community matured and grew, we could begin to take on consulting and development roles for local companies, or sell technologies that had been developed in-house. Both students and faculty, who would have already worked-out appropriate and functional methods for collaborative group-work could be outsourced for development projects. A full discussion of this third idea is both premature, and outside the scope of this paper. I realize that there are legal, logistical, economic, and policy issues that would need to be sorted out. Some of these may be insurmountable, I don't know. But at the very least I can imagine a time when Seneca is able to hire its own co-op students to manage and participate in the projects that are on-going in the college's open source community. The prospect is an exciting one for the future.

## Conclusion: What Now?

In writing this paper I have examined the results of my past effort at creating collaborative development experiences with a view to discovering the cause or causes of its failure. After spending time thinking about these projects I am convinced that the single greatest problem was the lack of community and a social infrastructure. In turning to open source I have recognized the need to not only create an open collaborative environment and infrastructure, but to create it in an open and collaborative way. My recent efforts where just that--my own. Without ownership of the process and what is produced by those involved, there is no commitment or growth. Thus, I believe that the way to begin what I have outlined above is to agree to open up, to discuss and criticize my points, to modify them so that they reflect the community of faculty and students of which we are all a part.

The question that needs to be answered then is this: what do we do now? And to this question I respond with my ideas, in the hope that you to will respond with yours.

1. We must be leaders and demonstrate this process in the way we design our infrastructure, courses, projects, etc. Before it can be adopted it must be modeled, it must be legitimized.
1. If the goal is an open collaborative environment where faculty and students can work together, we must begin with an open collaborative design process that includes faculty and students. Hopefully a group of interested faculty and students could be found to discuss these and other ideas.
1. We need to consider adopting parts of the university research models within the college. Rather than being a purely educational institution, we must become active in our field of programming, both for the sake of our faculty who must continually learn and re-learn, and for our students who rely on us to be relevant. In doing so we should not compete with the university, but recognize who we are and work out from that centre.
1. We must rethink the concept of "volunteerism" within the rewards-based "economy" of the college. For faculty this could mean honouring time spent on projects as leaders or developers, and recognizing this as real work, equal to teaching, marking, attending meetings, etc. For students this could mean establishing credit equivalencies for certain types and amounts of participation, such as designating independent study courses for credit. In whatever ways this is achieved, it will be important to find ways to properly support and therefore sustain the efforts of faculty and students who will be doing something new and outside the college's typical system of teaching/studying.

While I am conscious of the need to move beyond theory and into practical suggestions, I hesitate to offer more than I have done already. Instead, I look forward to the opportunity to think, discuss, and work together with my colleagues and students in ways that enrich the college, the community of teachers and learners, and the relationships we all share. Above all I look forward to discovering that I am not alone.
